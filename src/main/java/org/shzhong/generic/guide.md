# 泛型详解
https://blog.csdn.net/qq_27093465/article/details/73229016
https://blog.csdn.net/s10461/article/details/53941091

- 泛型类
- 泛型方法
- 通配符
    - https://segmentfault.com/a/1190000005337789
    >为了解决类型被限制死了不能动态根据实例来确定的缺点，引入了“通配符泛型”，针对上面的例子，使用通配泛型格式为<? extends Collection>，“？”代表未知类型，这个类型是实现Collection接口。
 注意：
 如果只指定了<?>，而没有extends，则默认是允许Object及其下的任何Java类了。也就是任意类。
 通配符泛型不单可以向下限制，如<? extends Collection>，还可以向上限制，如<? super Double>，表示类型只能接受Double及其上层父类类型，如Number、Object类型的实例。

上面有泛型的定义和赋值；当在赋值的时候，上面一节说赋值的都是为具体类型，当赋值的类型不确定的时候，我们用通配符(?)代替了：

如
List<?> unknownList;
List<? extends Number> unknownNumberList;
List<? super Integer> unknownBaseLineIntgerList;
 
在Java集合框架中，对于参数值是未知类型的容器类，只能读取其中元素，不能向其中添加元素， 因为，其类型是未知，所以编译器无法识别添加元素的类型和容器的类型是否兼容，唯一的例外是NULL

泛型牛逼的地方就是在这个地方。
如果你不用泛型，而使用Object类型，那么每次执行完之后，我们即使得到这个结果，还得类型转换一下，那么这下就像文章上面描述的那样。分分钟出现castfailexception。也就是类型转换异常啦。
但是，若是使用了这个泛型之后，那么我们的某个操作所需要的返回结果是什么类型，就可以 传入什么类型，而且在实际取得返回结果的时候，就不需要使用类型转换，这样就很好的达到了目的。
这个主要是代码设计层次的提高。写再多的业务代码，要是不提高，那么写的都是渣

基本的指导原则：
无论何时，如果你能做到，你就该尽量使用泛型方法。也就是说，如果使用泛型方法将整个类泛型化，那么就应该使用泛型方法。另外对于一个static的方法而已，无法访问泛型类型的参数。所以如果static方法要使用泛型能力，就必须使其成为泛型方法。